## Redis 常见面试题解析

1. 说下你在项目中的 Redis 应用场景？

   (1). Redis 的 5 大数据类型: String ( 字符串 ) , hash ( 哈希 ) , set ( 集合 ) , list ( 列表 ) , zset ( Sorted set: 有序集合 )

   (2). 基本上就是拿来做缓存.

   (3). 为的是服务无状态，项目中哪些数据结构和对象，单机时需要单机锁，集群中需要分布式锁，抽出来放入 Redis 中.

   

2. Redis 是单线程还是多线程？

   (1). 无论什么版本，工作线程就只有一个.

   (2). 6.x 版本出现了 I/O 多线程

   (3). I/O 多线程，把输入/输出放到 Worker 以外的线程中去并行，Worker 只负责计算，提高效率。 

   

3. Redis 存在线程安全的问题吗？为什么？

   (1).  Redis 可以保证内部执行的时候是串行的，需要在业务上自行保障顺序。

   

4. 遇到过缓存穿透吗？

   (1). 穿透是指没有这笔数据，会穿过 Redis ，查询数据库 ( 数据库也没这个数据 )，这种无效请求会消耗数据库的资源。

   (2). 解决方案: 1. key null  , 2. 布隆过滤器。

   (3). 阻止并发到数据库，通过 setnx key value 给这个 key 上锁 ， setnx 成功，访问数据库，失败则 sleep.

   

5. 缓存击穿？

   (1). 击穿是指 热点 key 过期 ( 或者压根没被缓存的 ) ，大量的并发打到数据库上( 数据库中有, 但是 Redis 上没有缓存 )

   (2).  请求 Redis , 没数据 -> 抢锁 -> 抢到的查询 DB ，没抢到的 Sleep -> 查到数据，更新 Redis -> Sleep 的回到第一步。

   

6. 如何避免缓存雪崩？

   (1). 雪崩是指 大量的 key 未命中 ( 大量的 key 缓存击穿 )

   

7. 缓存是如何回收的？怎么删除过期 key 的？

   (1). 后台轮询的时候，分段分批的删除过期 key

   (2). 请求的时候判断是否已经过期

   

8. 缓存是如何淘汰的?

   (1).  内存空间不足的情况下

   (2). LRU / LFU / Random / TTL

   

9. 如何进行缓存预热?

   (1).  你知道哪些是热数据？这肯定不知道啊，所以提前把数据塞入 Redis 。

   (2).  开发逻辑上要规避差集 ( 未缓存的 )，否则会造成穿透，击穿，雪崩。解决方案还是之前的锁。

   

10. 数据库与缓存不一致如何解决？

    (1).  分布式事务来解决 ( 没有意义 ) 

    (2). 看业务容忍度，可以通过 MQ ，MQ 发消息给消费端，消费端控制 MySQL 和 Redis 更新缓存。

    (3). Redis 是缓存，可以容忍稍微有时差 ，主要还是减少 DB 的操作，真要落地，就考虑用 Canal ，模拟成为数据库的从节点，通过 binlog 读取主库，刷新 Redis 缓存。

    

11. 简述主从不一致的问题？

    (1).  Redis 的确默认是弱一致性，同步是异步的。

    (2). 锁不能用主从( 单实例 / 分片集群 / Readlock )

    (3). 在配置中提供了必须有多少个 Client 连接能同步，可以配置同步因子，趋向于强一致性。

    (4). Wait , 违背 Redis 的初衷了。

    

12. 描述一下 Redis 持久化的方式，持久化原理？

    (1). RDB / AOF ；主从同步也算持久化。

    (2). 高版本: 开启 AOF ，是可以通过执行日志得到全部内存数据的。但是这样 AOF 会导致 AOF 文件变大，存在重写的问题 ( 例如某个 key 不断的重写 )，4.x 版本之后有性能模式，把重写方式换成 RDB 放到 AOF 文件头，再追加日志的方法。

    持久化原理: 异步后台进程完成持久化，从主进程 fork 一个子线程 + copy on write( 写时复制 )

13.  Redis 也扛不住了，大流量请求打到数据库上，该怎么处理？

    (1).  锁

    

14. 为什么使用 setnx ?

    (1). 原子性 

    (2). 如果要做分布式锁，就要用 set k v nx ex ( 不存在，过期时间，以避免死锁 )





### Redis 的事务是怎么实现的?

MULTI , EXEC , DISCARD 和 WATCH 是 Redis 事务相关的命令 。事务可以一次执行多个命令，并带有以下两个重要保证:

```
事务是一个单独的隔离操作: 事务中的所有命令都会序列化，按顺序地执行；事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

事务是一个原子操作: 事务中的命令要么全部被执行，要么全部都不执行。
```

EXEC 命令负责触发并执行事务中的所有命令:

```
如果客户端在使用 MULTI 开启了一个事务之后，却因为断线没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。

另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。
```

当使用 AOF 方式做持久化的时候， Redis 会使用单个 write (系统调用) 命令将事务写入磁盘。

然而，如果 Redis 服务器因为某些原因被管理员 kill ，或者遇到某个硬件故障，那么可能只有部分事务命令被成功写入磁盘中。

如果 Redis 在重启时发现 AOF 文件出现了这样的问题 ，那么它会退出，并汇报一个错误。

使用 redis-check-aof 命令可以修复这一问题: 它会移除 AOF 文件中不完整的事务信息，确保服务器可以顺利启动。